# backend/services/consent_service.py

import random
import uuid
from datetime import datetime
from typing import Optional, Tuple

from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession

from backend.db.models import Participant, Consent
from backend.schemas.consent import ConsentCreate, ConsentRead

class ConsentService:
    """
    Service layer for managing participant consent and session initialization.
    """

    def __init__(self, session: AsyncSession):
        self.session = session

    async def create_consent_session(self, consent_data: ConsentCreate) -> Consent:
        """
        Creates a new participant and a corresponding consent/session record.
        Assigns App and Paper randomly based on the 50/50 split specified in the plan.

        Args:
            consent_data: Input data containing demographics and baseline info.

        Returns:
            The newly created Consent database object.
        """
        # 1. Create a new Participant
        new_participant = Participant()
        self.session.add(new_participant)
        await self.session.flush() # Flush to get the generated participant_uuid
        await self.session.refresh(new_participant)

        # # 2. Assign App and Paper randomly (50/50 split)
        # assigned_app = random.choice(['App1', 'App2'])
        # Temporary modification for testing:
        assigned_app = 'App2' # Force assignment for testing App2 flow
        print(f"DEBUG: Forcing assignment to App2 for session testing.") # Optional debug print
        # assigned_app = random.choice(['App1', 'App2']) # Keep original commented out
        assigned_paper = random.choice(['Paper1', 'Paper2'])

        # 3. Create the Consent record
        new_consent = Consent(
            participant_uuid=new_participant.participant_uuid,
            # session_uuid is generated by default
            recruitment_timestamp=datetime.utcnow(), # Set when session is created
            demographics=consent_data.demographics,
            baseline_data=consent_data.baseline_data,
            assigned_app=assigned_app,
            assigned_paper=assigned_paper,
            # consent_timestamp, session_start/end_time, status are set later
        )
        self.session.add(new_consent)
        await self.session.flush() # Flush to get the generated session_uuid
        await self.session.refresh(new_consent)

        print(f"Created session {new_consent.session_uuid} for participant {new_participant.participant_uuid}, assigned to {assigned_app} / {assigned_paper}")

        return new_consent

    async def get_consent_session(self, session_uuid: uuid.UUID) -> Optional[Consent]:
        """Retrieves a consent session by its UUID."""
        result = await self.session.exec(select(Consent).where(Consent.session_uuid == session_uuid))
        return result.first()

    async def record_consent_agreement(self, session_uuid: uuid.UUID) -> Optional[Consent]:
        """
        Records the timestamp when a participant agrees to the consent form.

        Args:
            session_uuid: The UUID of the session to update.

        Returns:
            The updated Consent object or None if not found.
        """
        consent_session = await self.get_consent_session(session_uuid)
        if consent_session:
            if consent_session.consent_timestamp is None: # Only update if not already set
                consent_session.consent_timestamp = datetime.utcnow()
                self.session.add(consent_session)
                await self.session.flush()
                await self.session.refresh(consent_session)
            return consent_session
        return None

    async def start_session_task(self, session_uuid: uuid.UUID) -> Optional[Consent]:
        """
        Records the timestamp when the main task execution starts for the session.

        Args:
            session_uuid: The UUID of the session to update.

        Returns:
            The updated Consent object or None if not found.
        """
        consent_session = await self.get_consent_session(session_uuid)
        if consent_session:
             if consent_session.session_start_time is None: # Only update if not already set
                consent_session.session_start_time = datetime.utcnow()
                self.session.add(consent_session)
                await self.session.flush()
                await self.session.refresh(consent_session)
             return consent_session
        return None

    async def end_session(self, session_uuid: uuid.UUID, status: str) -> Optional[Consent]:
        """
        Records the end timestamp and status for the session.

        Args:
            session_uuid: The UUID of the session to update.
            status: The final status ('Completed', 'Abandoned', 'Error').

        Returns:
            The updated Consent object or None if not found.
        """
        consent_session = await self.get_consent_session(session_uuid)
        if consent_session:
            if consent_session.session_end_time is None: # Only update if not ended
                consent_session.session_end_time = datetime.utcnow()
                consent_session.session_status = status
                self.session.add(consent_session)
                await self.session.flush()
                await self.session.refresh(consent_session)
            return consent_session
        return None